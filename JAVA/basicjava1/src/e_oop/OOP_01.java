package e_oop;

public class OOP_01 {

	public static void main(String[] args) {
		/*
		 * OOP(objeect-Oriented programming) - 객체지향 프로그래밍
		 * 
		 * 1.객체지향 언어
		 * - 기존의 프로그래밍 언어에 몇가지 새로운 규칙을 추가한 보다 발전된 형태이다.
		 * -객체지향 언어의 특징
		 *  :코드의 재사용성이 높다.
		 *  :코드의 관리가 용이하다.
		 *  :신뢰성이 높은 프로그램이이 가능하다.
		 *  
		 *  2.클래스와 객체
		 *  -클래스란?
		 *   :객체를 정의해 놓은 것이다.
		 *   :객체의 설계도 또는 틀이다.
		 *   
		 *      -클래스의 선언
		 *      [접근제어자][지정예약어] class 클래스명[extends 클래스][implements 인터페이스]
		 *      public abstract class Child extends Parents implements Serializable{}
		 *      
		 *	-객체란?
		 *	:실제로 존재하는 것, 사물또는 개념
		 *	:구성요소
		 *		-속성 = 멤버변수  ,특성 플드, 상태
		 *		 -> 전원, 채널, 볼륨, 등등
		 *		-기능 = 메서드 (동사적인것) 행위, 함수 function
		 *		 -> 전원켜기, 전원끄기, 채널올리기, 채널 내리기
		 * 
		 * 3. 인스턴스란?
		 * -클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화 라고 한다.
		 * -Tv클래스로부터 만들어진 객체를 Tv클래스의 인스턴스라고 한다.
		 * -인스턴스 생성방법
		 * 	클래스명 변수명; //클래스 티입의 참조변수를 선언
		 * 	변수명 = new 클래스(); //클래스의 객체를 생성후 객체의 주소를 참조변수에 저장
		 * 
		 *	인스턴스는 참조변수를 통해서만 다룰수 있으며 참조변수의 타입은 인스턴스의 타입과 일치해야 하다.
		 *
		 * 4.선언위치에 따른 변수의 종류
		 * 	-전역변수 (클래스변수, 인스턴스변수), 지역변수
		 * 	-인스턴스변수
		 * 		:클래스의 영역에 선언되며, 클래스의 인스턴스가 생성될때 같이 만들어진다.
		 * 		:인스턴스 변수의 값을 읽어 오거나 저장하기 위해서는 인스턴스를 먼저 생성해야 한다.
		 * 		:인스턴스는 동립적인 저장공간을 가지므로 서로다른 값을 가질수 있다.
		 * 	
		 * 	-클래스변수
		 * 		:클래스의 영역에 선언, 모든 인스턴스가 공통된 저장공간(변수)를 공유하게된다.
		 * 		:한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야 하는 경우 클래스 변수로 선언한다.
		 * 		:인스턴스 변수에 static만 붙이면 된다.
		 * 
		 *  -지역변수
		 * 		:메서드내에 선언되며 메서드 내에서만 사용가능하다
		 * 		:메서드 종료시 소멸된다.
		 * 		:for문 또는 while문의 블럭내에서 선언 된 변수는 해당 반복문이 종료되면 소멸
		 * 		
		 * 5.메서드
		 *  -어떤작업을 수행하기 위한 명령문의 집합
		 *  -주로 어떤 값을 입력받아서 처리하고 그 결과를 돌려준다.
		 *  -입력값이 없을수도 결과를 반환하지 않을수도 있다.
		 *  -반복적으로 사용되는 코드를 줄이기 위해서 사용된다.=>코드양이줄고 유지보수에 좋다.
		 *  -작성방법
		 *  1.메서드명 >변수타입 변수명(매개변수) > 명력문으로 들어간다(타입과 개수 > 처리) > retrun값 > 반환타입 
		 *  	반환타입 메서드명(입력받는값 변수타입 변수명....){=>매개변수
		 *  		//처리
		 *   		//retrun 값;
		 *  	}
		 *  	int add(int a, int b){//타입과 개수중요
		 *  		int result = a+b
		 *  		return result;
		 *  	}
		 *  
		 *  6.return문
		 *  -메서드가 정샂억으로 종료되는 경우
		 *  	:메서드의 블력{}내의 마지막 문장까지 수행하였을 경우
		 *  	:메서드의 블력{}내에서 return문을 만났을때
		 *  -반환값
		 *  	:반환값이 있는 경우 
		 *  	 ->return문 뒤에 반환값을 지정해 주면된다.
		 *  	 ->반환값의 타입과 메서드의 반환타입이 같아야 한다.
		 *  	:반환값이 없는 경우
		 *  	 ->return; > 반환타입 생략가능
		 *  	 ->메서드의 반환타입에 void라고 적는다.
		 *  
		 *  7.메서드의 호출
		 *  -클래스메서드
		 *  	:클래스명.메서드명()
		 *  -인스턴스 메서드
		 *  	:인스턴스화 > 참조변수명.메서드명(값,값,,,,,)
		 *  -매서드
		 *  
		 *  8.JVM메모리 구조
		 *  -메서드 영역 Method Area
		 *  	클래스가 로드되며 클래스변수와 클래스 메서드가 함께 로드된다.
		 *  -호출스텍 Call stack
		 *  	메서드 작업에 필요한 메모리 공간을 제공
		 *  -힙영역Heap Area
		 *  	인스턴스가 로드된다.
		 *  	인스턴스 변수와 인스턴스 메서드가 로드된다.
		 *  
		 *  9.재귀호출Recursive call
		 *  -메서드 내부에서 메서드 자기자신을 다시 호출
		 *  
		 *  10. 메서드의 종류
		 *  -클래스 메서드
		 *  	객체생성없이 클래스가 로두될때 함께 로드된다.
		 *  	형테 => 클래스명.메서드명(인자값)
		 *  	인스턴스멤버와 관련 없는 작업을 수행***
		 *  	클래스 메서드 내에서는 인스턴스 멤버를 호출 못한다.****
		 *  -인스턴스메서드
		 *  	인스턴스가 생성될때 로드 (인스턴스변수,메서드가 생성되어있다면클래스변수,메서드는 이미 생성되어있다.)
		 *  	참조변수명.메서드명(인자값) => 클래스 객체를 먼저생성
		 *  	인스턴스 멤버와 관련되 작업을 수행한다.*****
		 *  	인스턴스 메서드 내에서는 모든 멤버를 호출가능(클레스멤버,인스턴스멤버 호출가능)
		 *  
		 *  11. 메서드 오버로딩
		 *  -한 클래스 내의 같은 이름의 메서드를 여러개 정의하는 것
		 *  -가장 대표적인 예 println()
		 *  -조건
		 *  	메서드이름 동일
		 *  	메개변수의 개수또는 타입이 달라야 한다.
		 *  	반환타입은 상관없다.
		 *  -오버로딩의 장접
		 *  	메서드의 이름으로만 구분된다면 모든 이름의 메서드의 이름이 달라야한다.
		 *  	같은 기능을 하는데 다른이름이면 찾기업렵다
		 *  	메서드의 이름생성이 편하다	
		 *  
		 *  12. 배개변수
		 *  -메서드를 호출할때 메게변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨준다.
		 *  -기본현 매개변수
		 *   단순히 저장된 값만을 호출한다.
		 *   변수의 값을 읽기만 할 수있다.
		 *  -참조형 매개변수
		 *   인스턴스의 주소가 복사된다.
		 *   인스턴스 변수의 값을 
		 *  
		 *  13.생성자
		 *  -인스턴스가 생성될때 호출되는 인스턴스 초기화 메서드 이다.
		 *  -특징
		 *  	메서드처럼 클래스내에 선언된다.	
		 *  	반환값이 없다. => 생성자도 메서드 이기 때문에 void를 적어주어야 하지만
		 *  					모든 생성자는 반환값이 없기 때문에 생략한다.
		 *  -작성방법
		 *  	기본생성자
		 *  	-클래스명(){}
		 *  	매개변수가 있는 생성자
		 *  	-클래스명(매개변수){}
		 *  
		 *  14. 변수의 초기화
		 *  -변수를 선언하고 처음으로 값을 저장하는 것을 변수의 초기화
		 *  -초기화 방법
		 *  	명시적 초기화
		 *  	 =>변수의 선언과 동시에 초기화한다.
		 *  	생성자를 이용한 초기화
		 *  	 =>
		 *  	초기화 블럭을 이용한 초기화
		 *  	 =>{ 수식계산 } 
		 *  
		 */

		
		
		
	}
}
