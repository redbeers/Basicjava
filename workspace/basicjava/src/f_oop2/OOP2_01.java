package f_oop2;

public class OOP2_01 {
	public static void main(String[] args) {
		
		/*
		1. 상속(is ~a)
		- 기존의 클래스를 재사용하여 새로운 클래스를 작성한다.
		- 적은 양의 코드로 새로운 클래스를 작성할 수 있다.
		- 새로 작성하고자 하는 클래스 뒤에 상속받고자 하는 클래스의 이름을
		'extends' 와 함께 써주기만 하면 된다.
		
		ex) class Child extends Parent{
			
		}
		
		- 상속해주는 클래스를 조상클래스, 상속받는 클래스를 자손클래스라고 한다.
		: 조상클래스 -> 부모클래스, 상위클래스, 기반클래스
		: 자손클래스 -> 자식클래스, 하위클래스, 파생된클래스
		
		- 멤버만 상속된다
		: 멤버변수와 메서드만 상속이 된다!
		
		- 자손클래스의 멤버의 개수는 조상클래스보다 항상 같거나 많다.
		
		
		2. 포함(has ~a)
		- 상속이외에 클래스를 재사용하는 방법
		- 한 클래스의 멤버변수로 다른 클래스를 선언하는 방법
		- 원은 점을 포함하고 있다
		
		- toString(), toString메서드
		: 앞에 변수한테 문자열로 만들어서 돌려준다 ds.toString()
		: 해당인스턴스의 정보를 보여주기 위해서
		: 인스턴스의 정보를 반환할 목적으로 만들어졌다.
		
		
		3. 단일 상속
		- 자바에서는 단일 상속(두개 이상은 불가)만 가능하다.
		
		ex)
		class TVCR extends TV,VCR{
		//TVCR은 TV의 기능을 가지고 있다 ->포함관계가 더 적절
		
		}
		=>불가:TV와 VCR에 같은 메서드가 존재할 때 어떤 것을 상속받을지 알 수 없다
		해결하기 위해 매서스명을 바꾼다면 기존에 사용하던 모든 곳을 수정해주어야 한다
		클래스 간의 관계가 보다 명확해지고 더욱 신뢰할 수 있도록 해준다.
		
		
		4. Object클래스
		- 모든 클래스의 상속계층도의 제일 위에 위치하는 조상클래스이다.
		- 다른 클래스로부터 상속받지 않는 클래스는 Object클래스를 상속받는다.
		ex)
		class Tv{
		
		}
		class Tv extends Object{
		
		}
		- toString(), equals()와 같은 메서드를 따로 정의하지 않고 
		사용하는 것은 Object클래스에 정의된 것이기 때문이다.
		
		
		5. 오버라이드(override)
		- 조상 클래스로부터 상속받은 메서드의 내용을 수정하는 것
		- 중괄호 열리기 전까지 선언부 이후 구현부 
		- 오버라이드의 조건(선언부가 일치해야 한다)
		: 상속받는 메서드의 이름이 같아야 한다
		: 매개변수의 개수와 타입이 같아야한다
		: 반환타입은 같아야 한다.
		
		- 조상클래스의 메서드를 자손클래스에서 오버라이드 할때는
		접근제어자를 조상클래스의 메서드보다 좁은 범위를 선택할 수 없다.
		예외는 조상클래스의 메서드보다 많이 선언할 수 없다.
		인스턴스 메서드를 클래스 메서드로 변경할 수 없다.
		
		
		6. super.
		- 조상클래스의 멤버(멤버변수와 클래스 다 포함)와 자손클래스의 멤버가 중복정의되어
		서로 구분해야 하는 경우 사용한다
		- 사용은 자손클래스의 멤버에서만 가능하다.
		- 조상의 멤버와 객체 자신의 멤버를 구분하는데 사용된다는 점을 제외하고는 this.과 동일하다
		- 클래스메서드에는 사용할 수 없고 인스턴스 메서드에만 사용이 가능하다 
		
		
		7. super()
		- this()와 마찬가지로 super()역시 생성자 호출이다
		- this()는 같은 클래스의 다른 생성자를 호출할때 사용하고,
		super()는 자손클래스의 생성자에서 부모클래스의 생성자를 호출할 때 사용한다
		- 생성자를 호출할 때는 생성자의 가장 첫 줄에 써야한다***
		
		
		8. 제어자
		- 클래스, 메서드, 변수의 선언부에 사용된다
		- 접근제어자(4개)와 그외 제어자로 나누어 진다
		- 접근제어자 : public, protected, default, private->하나만 고를 수 있다
		- 그외제어자 : static, final, abstract...
		- 접근제어자와 그외제어자가 동시에 존재할 수 있다
		- 접근제어자와 그외제어자가 동시에 있을 때 접근제어자를 가장 왼쪽에 쓴다
		
		- static(클래스의, 공통적인)
		: 메서드와 변수, 초기화블럭에만 사용가능하다(클래스 친구들 호출할때)
		: 클래스변수
		->모든 인스턴스에서 공통적으로 사용하는 변수
		->인스턴스를 생성하지 않고 '클래스명.변수명'으로 호출한다
		->클래스가 메모리에 로드될 때 함께 로드된다
		->주의할 점:클래스멤버에서는 인스턴스멤버를 호출 할 수 없다!!!
		
		- final(마지막의, 변경할 수 없는)
		: 변수에 사용시 값을 변경할 수 없는 상수가 된다
		: 메서드에 사용시 오버라이드가 불가능하다
		: 클래스에 사용시 부모클래스가 될 수 없다
		
		-abstract(추상의, 미완성된)
		: 메서드에 사용시 선언부만 작성을 하고 구현부는 작성되지 않는다.
		: 클래스에 사용시 추상메서드를 가지고 있는 클래스임을 알린다.
		(추상메서드를 하나라도 가지고 있으면 추상클래스가 된다)
		
		
		9. 접근제어자
		- public : 접근제한이 없다. 프로젝트내
		- protected : 같은 패키지 + 다른 패키지의 자손클래스
		- default : 같은 패키지내에서 호출 가능
		- private : 같은 클래스내에서 호출 가능
		
		- 멤버변수와 메서드에는 전부 사용가능
		- 하지만 클래스에는 public, default만 사용가능하다
		
		
		10. 생성자의 접근제어자
		- 인스턴스의 생성을 제한할 수 있다.
		- 생성자의 접근제어자를 private으로 변경
		: 객체생성이 불가하다
		: 상속도 불가하다 => 타클래스의 조상이 될 수 없다
		: 상속할 수 없는 클래스임으로 final을 추가하여 상속할 수 없는 클래스임을 알리는 것이 좋다
		- singleton패턴
		
		
		11. 캡슐화
		- 접근제어자를 사용하는 이유
		: 외부로부터 데이터를 보호하기 위해
		: 외부에는 불필요한 내부적으로만 사용되는 부분을 감추기 위해
		
		
		12. 다형성(polymorphism)
		- 많은 형태를 가질 수 있는 성질
		- 여러가지 형태를 가질 수 있는 능력
		- 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있다.
		- 부모타입의 참조변수로 자식타입의 인스턴스를 참조할 수 있다.****
		
		
		13. 참조변수의 형변환
		- 서로 상속관계에 있는 클래스간에는 형변환이 가능하다.
		- 자식타입 -> 부모타입 : up-casting => 생략가능
		- 부모타입 -> 자식타입 : down-casting => 생략불가
		
		
		14. instanceof
		- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용한다
		- 판단한 결과(연산결과)가 true라면 참조변수가 검사한 타입으로 형변환이 가능하다.
		- 클래스메서드는 클래스변수처럼 참조변수의 타입에 영향을 받는다
		- 참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다***
		**** 오버라이드를 한 목적이 사라지니까 부모것을 쫓아가는게 아니라 내가 수정해놓은 자식것을 어떻게든 찾는다!!!
		
		
		15. 매개변수의 다형성
		- 참조변수의 다형적인 특징은 매개변수에도 적용이 된다
	
		FireCar fc = new FireCar();
		(fc instanceof Car)
		
		
		16. 여러객체 배열 Vector
		- 배열을 사용할 경우 전체 크기를 한 번 정하면 변경이 불가하다
		- 이를 Vector클래스를 이용하여 해결할 수 있다.
		- 동적으로 크기가 관리되는 객체배열 이라고 생각하면 된다
		
		- Vector클래스의 메서드
		: Vector() => 10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다(초기값 null)
		(create, read, update, delete)
		: add() => 객체를 추가할 때 사용한다.
		: get(int index) => index번째 방의 객체를 반환한다	
		: remove() => 객체를 삭제한다
		: isEmpty() => Vector의 값이 비어 있는지 확인한다
		: size() => 객체의 개수를 반환한다
		
		
		17. 추상클래스(abstract class)
		- 추상메서드
		: 메서드는 선언부와 구현부로 구성되어 있다.
		: 선언부만 작성이 되고 구현부는 작성하지 않은 메서드를 추상 메서드라고 한다.
		: 구조
			abstract 반환타입 메서드명(매개변수);
			
		- 추상클래스
		: 추상메서드를 포함하고 있는 클래스
	 	: abstract class 클래스명{
	 	
	 	}
	 	
	 	
	 	18. 인터페이스(interface)
	 	- 일종의 추상클래스이지만 추상메서드와 상수만을 멤버로 가질 수 있다.
	 	- 인터페이스 작성방법
	 	: interface 인터페이스명{
	 		public static final 변수타입 변수명 = 값;
	 		public abstract 반환타입 메서드명(매개변수);
	 	}
	 	
	 	: 모든 멤버변수는 public static final이어야 한다. => 생략가능
	 	: 모든 메서드는 public abstract 이어야 한다. => 생략가능
		
		- 인터페이스의 상속
		: 인터페이스는 클래스를 상속받을 수 없다(정상적인 녀석 가지고 있으면 더 이상 인터페이스가 아니고 그냥 추상클래스가 된다)
		: 인터페이스는 인터페이스만 상속받을 수 있다.
		: 인터페이스는 다중 상속이 가능하다.(선언부만 만들어져 있으니까 노상관)
		
		- 인터페이스의 구현
		: 자체로는 인스턴스를 생성할 수 없다
		: 인터페이스 멤버-추상메서드와 상수 =>생성자 자체가 없다!=>객체 생성이 불가
		: 자신이 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 한다
		: 이 인터페이스를 가져가서 쓸때 없는 부분을 만드는거니까 오버라이드가 아니라 구현한다라고 표현
		
		: 클래스의 확장(extends), 인터페이스의 구현에는 implements 를 사용한다
		
		: ~able(~을 할 수 있는) - 인터페이스 명칭 뒤에 붙었다 예전에는 자바
		=> 필요한 메서드를 제공한다는 의미를 강조하기 위해서 쓴다
		
		: Imember => ImemberImpl(개발자들끼리 약속)
		
		- 인터페이스의 장점
		: 개발시간을 단축시킬 수 있다.
		: 표준화가 가능하다.
		: 서로 관계가 없는 클래스들에게 관계를 맺어줄 수 있다.
		: 독립적인 프로그래밍이 가능하다
		
		- 인터페이스의 이해
		: 클래스를 사용하는 쪽(user)과 제공하는 쪽(provider)이 있다.
		: 메서드를 사용하는 쪽에서는 사용하려는 메서드의 선언부만 알면된다.
		 A라는 사람이 B를 사용해야함
		 B는 그럼 선언부만 보여주면 된다
		 =>A - I - B
		 
		 - 인터페이스의 다형성
		 : 부모타입의 참조변수로 자식타입의 인스턴스를 참조할 수 있다(다형성)
		 : 인터페이스의 타입의 참조변수로 그를 구현한 구현체의 인스턴스(쉽게 생각하면 자식타입)를 참조할 수 있다
		
		
		19. 내부클래스
		- 클래스내에 선언된 클래스이다.
		- 서로 쉽게 접근할 수 있고 외부에는 불필요한 클래스를 감춤으로 복잡성을 줄일 수 있다.
		
		- 내부클래스의 종류 4가지
		1) 인스턴스클래스
		: 외부클래스의 인스턴스 멤버와 관련된 작업을 수행한다
		2) static클래스
		: 외부클래스의 클래스 멤버와 관련된 작업을 수행한다
		3) 지역클래스
		: 선언 영역 내에서만 사용가능
		4) 익명클래스
		: 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스
		
		
		
		
		
		 */
		
		
		
		
	}

}
